
<html>
<head>
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css">
	<script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"></script>
    <script src='https://unpkg.com/mapillary-js@2.20.0/dist/mapillary.min.js'></script>
    <link href='https://unpkg.com/mapillary-js@2.20.0/dist/mapillary.min.css' rel='stylesheet' />
<style>
.relative {
    position: relative;
}
.absolute {
    position: absolute;
    left: 0px;
    top: 0px;
}
#mly {
	width: 640px;
	height: 480px;

}
#mapcontainer {
	width: 640px;
	height: 480px;

}
#map, #photo, #calc {
	margin: 10px;
	float:left;
}
</style>

</head>

<body>
<h1>Set Mapillary URL (360 PHOTO ONLY!)</h1>
<input type="url" size="160" id="mapillaryurl" value="https://www.mapillary.com/app/?lat=37.48689999999999&lng=139.9298&z=20&pKey=JQJrg5HaJ4Q0QvYCP-L9GQ&focus=photo&x=0.7402020403448308&y=0.5212907903987006&zoom=0"><input type="button" value="Open 360 photo" onclick="loadMapillary()">



<div id="photo">
<h1>Measure Angle</h1>
<div id='mly'></div>
</div>

<div id="map">
<h1>Measure Distance</h1>
<div id='mapcontainer'></div>
</div>
<div id="calc">
<h1>Calc Height</h1>
<p><form onsubmit="return false" oninput="result.value = Number(distance.value) * Math.tan(Number(theta.value)*Math.PI/180);" />

<ul>
	<li>Distance[m]: <input type="number" name="distance" id="distance"> m
	<li>Angle[deg]: <input type="number" name="theta" id="theta"> deg
	<li><strong>Height[m] = <code>Distance * tan(Angle*&pi;/180)</code> = <u><output name="result"></output> m</u></strong>
</ul>
</div>
<script src="leaflet.rotatedMarker.js"></script>
<script>

const client_id = 'NEh3V0ZjaE1fT1Nkdk9jMnJlSGNQQTo1NzRiNDEwZmM3MzZhNmIw';

let mly;
let map;
let camera_marker;
let target_marker;

init();

function init(){
	initPhoto();
	initMap();
	drawGrid();
}
function initPhoto(){
	mly = new Mapillary.Viewer(
		'mly',
		client_id,
		// photo id
		null,
		{
			component: {
				cover: false,
				tag: true,
			},
        });
	mly.on(Mapillary.Viewer.nodechanged, function(node) {
		console.log("Mapillary.js node changed:", node.key);
		const latLon = node.latLon;
		map.setView(latLon, 18);
		camera_marker.setLatLng(latLon).addTo(map);
		
	});
	mly.on(Mapillary.Viewer.povchanged, function(node) {

		mly.getPointOfView().then((pov) => {
			//camera_marker.addTo(map)
			camera_marker.setRotationAngle(pov.bearing);
		});

	});	
}
function initMap(){
//地図を表示するdiv要素のidを設定
map = L.map('mapcontainer');
  //地図の中心とズームレベルを指定
  map.setView([0, 0], 1);
  //表示するタイルレイヤのURLとAttributionコントロールの記述を設定して、地図に追加する
  const osmLayer = L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
	  attribution: "(C)<a href='https://www.openstreetmap.org/copyright' target='_blank'>OpenStreetMap contributors</a>",
	  maxZoom: 21,
	  maxNativeZoom: 19,
	  minZoom: 1,
	  //maxBounds: [[35.47, 139.62], [35.45, 139.64]],
  }).addTo(map);
  map.options.singleClickTimeout = 250;
  map.on('click',function ( e ) {
	target_marker.setLatLng(e.latlng).addTo(map);

        } );

	const sampleIcon = L.icon({
		iconUrl: 'icon.png',
		iconRetinaUrl: 'icon.png',
		iconSize: [50, 50],
		iconAnchor: [25, 25],
		popupAnchor: [25, -25],
		className: "marker_icon",
	});

	camera_marker = L.marker([0,0], { icon: sampleIcon, rotationAngle: 45, draggable: true });
	camera_marker.on('move',function(event){
		showDistance();

  	});

	target_marker = L.marker([0,0], { draggable: true });
	target_marker.on('move',function(event){
		showDistance();

  	});
}

function showDistance(){
	const [distance, phi] = getDistancePhi(camera_marker.getLatLng(), target_marker.getLatLng());
	if (distance < 1000) {document.getElementById("distance").value = distance;}
	else {};
}


var loadMapillary = function(){
	var murl = document.getElementById("mapillaryurl").value;
	const [,lat,lon,mid] = murl.match(/lat=(-?\d[0-9.]*).*&lng=(-?\d[0-9.]*).*pKey=([^&]*)&/);

	mly.moveToKey(mid);
}

function drawGrid(){
	let tagComponent = mly.getComponent("tag");
	
	let tag_number = 0;
	for (let angle = -80; angle < 90; angle += 5){
		const div_number = 10;
		for (let i = 0; i < div_number; i++){
			let rect = [i/div_number, (-angle+90)/180, (i+1)/div_number, (-angle+90)/180];
			let rectGeometry = new Mapillary.TagComponent.RectGeometry(rect);
			let rectTag = new Mapillary.TagComponent.OutlineTag('tag-' + tag_number, rectGeometry, { lineWidth: 10, text: angle});
			tagComponent.add([rectTag]);
			tag_number++;
			
		}
	}
	/*
	var rect = [0.68, 0.51, 0.72, 0.56];
        var rectGeometry = new Mapillary.TagComponent.RectGeometry(rect);
        var rectTag = new Mapillary.TagComponent.OutlineTag('rectTag', rectGeometry, { text: "stop sign"});
		tagComponent.add([rectTag]);
	*/
        window.addEventListener("resize", function() { mly.resize(); });
}

const R = 6378100;	
function getDistancePhi(base, target){
	const x1 = rad(base.lng);
	const y1 = rad(base.lat);
	const x2 = rad(target.lng);
	const y2 = rad(target.lat);

	const dx = x2 - x1;

	const distance = R * Math.acos(Math.sin(y1)*Math.sin(y2) + Math.cos(y1)*Math.cos(y2)*Math.cos(dx));
	const phi = 90 - deg(Math.atan2( Math.cos(y1)*Math.tan(y2) - Math.sin(y1)*Math.cos(dx), Math.sin(dx)));

	return [distance, phi];
}
function rad(deg){
	return deg/180*Math.PI;
}

function deg(rad){
	return rad/Math.PI*180;
}
</script>
</body>


</html>
